{"ast":null,"code":"import React, { useMemo, useRef, useEffect, useState, useContext } from 'react';\nimport { useDndContext, getClientRect, useDroppable, useDraggable, closestCorners, getFirstCollision, getScrollableAncestors, KeyboardCode } from '@dnd-kit/core';\nimport { useUniqueId, useIsomorphicLayoutEffect, CSS, useCombinedRefs, isKeyboardEvent } from '@dnd-kit/utilities';\n/**\r\n * Move an array item to a different position. Returns a new array with the item moved to the new position.\r\n */\n\nfunction arrayMove(array, from, to) {\n  const newArray = array.slice();\n  newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from, 1)[0]);\n  return newArray;\n}\n/**\r\n * Swap an array item to a different position. Returns a new array with the item swapped to the new position.\r\n */\n\n\nfunction arraySwap(array, from, to) {\n  const newArray = array.slice();\n  newArray[from] = array[to];\n  newArray[to] = array[from];\n  return newArray;\n}\n\nfunction getSortedRects(items, rects) {\n  return items.reduce((accumulator, id, index) => {\n    const rect = rects.get(id);\n\n    if (rect) {\n      accumulator[index] = rect;\n    }\n\n    return accumulator;\n  }, Array(items.length));\n}\n\nfunction isValidIndex(index) {\n  return index !== null && index >= 0;\n} // To-do: We should be calculating scale transformation\n\n\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1\n};\n\nconst horizontalListSortingStrategy = _ref => {\n  let {\n    rects,\n    activeNodeRect: fallbackActiveRect,\n    activeIndex,\n    overIndex,\n    index\n  } = _ref;\n\n  var _rects$activeIndex;\n\n  const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  const itemGap = getItemGap(rects, index, activeIndex);\n\n  if (index === activeIndex) {\n    const newIndexRect = rects[overIndex];\n\n    if (!newIndexRect) {\n      return null;\n    }\n\n    return {\n      x: activeIndex < overIndex ? newIndexRect.left + newIndexRect.width - (activeNodeRect.left + activeNodeRect.width) : newIndexRect.left - activeNodeRect.left,\n      y: 0,\n      ...defaultScale\n    };\n  }\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: -activeNodeRect.width - itemGap,\n      y: 0,\n      ...defaultScale\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: activeNodeRect.width + itemGap,\n      y: 0,\n      ...defaultScale\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale\n  };\n};\n\nfunction getItemGap(rects, index, activeIndex) {\n  const currentRect = rects[index];\n  const previousRect = rects[index - 1];\n  const nextRect = rects[index + 1];\n\n  if (!currentRect || !previousRect && !nextRect) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect ? currentRect.left - (previousRect.left + previousRect.width) : nextRect.left - (currentRect.left + currentRect.width);\n  }\n\n  return nextRect ? nextRect.left - (currentRect.left + currentRect.width) : currentRect.left - (previousRect.left + previousRect.width);\n}\n\nconst rectSortingStrategy = _ref2 => {\n  let {\n    rects,\n    activeIndex,\n    overIndex,\n    index\n  } = _ref2;\n  const newRects = arrayMove(rects, overIndex, activeIndex);\n  const oldRect = rects[index];\n  const newRect = newRects[index];\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.left - oldRect.left,\n    y: newRect.top - oldRect.top,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height\n  };\n};\n\nconst rectSwappingStrategy = _ref3 => {\n  let {\n    activeIndex,\n    index,\n    rects,\n    overIndex\n  } = _ref3;\n  let oldRect;\n  let newRect;\n\n  if (index === activeIndex) {\n    oldRect = rects[index];\n    newRect = rects[overIndex];\n  }\n\n  if (index === overIndex) {\n    oldRect = rects[index];\n    newRect = rects[activeIndex];\n  }\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.left - oldRect.left,\n    y: newRect.top - oldRect.top,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height\n  };\n}; // To-do: We should be calculating scale transformation\n\n\nconst defaultScale$1 = {\n  scaleX: 1,\n  scaleY: 1\n};\n\nconst verticalListSortingStrategy = _ref4 => {\n  let {\n    activeIndex,\n    activeNodeRect: fallbackActiveRect,\n    index,\n    rects,\n    overIndex\n  } = _ref4;\n\n  var _rects$activeIndex;\n\n  const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  if (index === activeIndex) {\n    const overIndexRect = rects[overIndex];\n\n    if (!overIndexRect) {\n      return null;\n    }\n\n    return {\n      x: 0,\n      y: activeIndex < overIndex ? overIndexRect.top + overIndexRect.height - (activeNodeRect.top + activeNodeRect.height) : overIndexRect.top - activeNodeRect.top,\n      ...defaultScale$1\n    };\n  }\n\n  const itemGap = getItemGap$1(rects, index, activeIndex);\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: 0,\n      y: -activeNodeRect.height - itemGap,\n      ...defaultScale$1\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: 0,\n      y: activeNodeRect.height + itemGap,\n      ...defaultScale$1\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale$1\n  };\n};\n\nfunction getItemGap$1(clientRects, index, activeIndex) {\n  const currentRect = clientRects[index];\n  const previousRect = clientRects[index - 1];\n  const nextRect = clientRects[index + 1];\n\n  if (!currentRect) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect ? currentRect.top - (previousRect.top + previousRect.height) : nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;\n  }\n\n  return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : previousRect ? currentRect.top - (previousRect.top + previousRect.height) : 0;\n}\n\nconst ID_PREFIX = 'Sortable';\nconst Context = /*#__PURE__*/React.createContext({\n  activeIndex: -1,\n  containerId: ID_PREFIX,\n  disableTransforms: false,\n  items: [],\n  overIndex: -1,\n  useDragOverlay: false,\n  sortedRects: [],\n  strategy: rectSortingStrategy\n});\n\nfunction SortableContext(_ref5) {\n  let {\n    children,\n    id,\n    items: userDefinedItems,\n    strategy = rectSortingStrategy\n  } = _ref5;\n  const {\n    active,\n    dragOverlay,\n    droppableRects,\n    over,\n    measureDroppableContainers,\n    measuringScheduled\n  } = useDndContext();\n  const containerId = useUniqueId(ID_PREFIX, id);\n  const useDragOverlay = Boolean(dragOverlay.rect !== null);\n  const items = useMemo(() => userDefinedItems.map(item => typeof item === 'string' ? item : item.id), [userDefinedItems]);\n  const isDragging = active != null;\n  const activeIndex = active ? items.indexOf(active.id) : -1;\n  const overIndex = over ? items.indexOf(over.id) : -1;\n  const previousItemsRef = useRef(items);\n  const itemsHaveChanged = !isEqual(items, previousItemsRef.current);\n  const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;\n  useIsomorphicLayoutEffect(() => {\n    if (itemsHaveChanged && isDragging && !measuringScheduled) {\n      measureDroppableContainers(items);\n    }\n  }, [itemsHaveChanged, items, isDragging, measureDroppableContainers, measuringScheduled]);\n  useEffect(() => {\n    previousItemsRef.current = items;\n  }, [items]);\n  const contextValue = useMemo(() => ({\n    activeIndex,\n    containerId,\n    disableTransforms,\n    items,\n    overIndex,\n    useDragOverlay,\n    sortedRects: getSortedRects(items, droppableRects),\n    strategy\n  }), [activeIndex, containerId, disableTransforms, items, overIndex, droppableRects, useDragOverlay, strategy]);\n  return React.createElement(Context.Provider, {\n    value: contextValue\n  }, children);\n}\n\nfunction isEqual(arr1, arr2) {\n  return arr1.join() === arr2.join();\n}\n\nconst defaultNewIndexGetter = _ref6 => {\n  let {\n    id,\n    items,\n    activeIndex,\n    overIndex\n  } = _ref6;\n  return arrayMove(items, activeIndex, overIndex).indexOf(id);\n};\n\nconst defaultAnimateLayoutChanges = _ref7 => {\n  let {\n    containerId,\n    isSorting,\n    wasDragging,\n    index,\n    items,\n    newIndex,\n    previousItems,\n    previousContainerId,\n    transition\n  } = _ref7;\n\n  if (!transition || !wasDragging) {\n    return false;\n  }\n\n  if (previousItems !== items && index === newIndex) {\n    return false;\n  }\n\n  if (isSorting) {\n    return true;\n  }\n\n  return newIndex !== index && containerId === previousContainerId;\n};\n\nconst defaultTransition = {\n  duration: 200,\n  easing: 'ease'\n};\nconst transitionProperty = 'transform';\nconst disabledTransition = /*#__PURE__*/CSS.Transition.toString({\n  property: transitionProperty,\n  duration: 0,\n  easing: 'linear'\n});\nconst defaultAttributes = {\n  roleDescription: 'sortable'\n};\n/*\r\n * When the index of an item changes while sorting,\r\n * we need to temporarily disable the transforms\r\n */\n\nfunction useDerivedTransform(_ref8) {\n  let {\n    disabled,\n    index,\n    node,\n    rect\n  } = _ref8;\n  const [derivedTransform, setDerivedtransform] = useState(null);\n  const previousIndex = useRef(index);\n  useIsomorphicLayoutEffect(() => {\n    if (!disabled && index !== previousIndex.current && node.current) {\n      const initial = rect.current;\n\n      if (initial) {\n        const current = getClientRect(node.current, {\n          ignoreTransform: true\n        });\n        const delta = {\n          x: initial.left - current.left,\n          y: initial.top - current.top,\n          scaleX: initial.width / current.width,\n          scaleY: initial.height / current.height\n        };\n\n        if (delta.x || delta.y) {\n          setDerivedtransform(delta);\n        }\n      }\n    }\n\n    if (index !== previousIndex.current) {\n      previousIndex.current = index;\n    }\n  }, [disabled, index, node, rect]);\n  useEffect(() => {\n    if (derivedTransform) {\n      requestAnimationFrame(() => {\n        setDerivedtransform(null);\n      });\n    }\n  }, [derivedTransform]);\n  return derivedTransform;\n}\n\nfunction useSortable(_ref9) {\n  let {\n    animateLayoutChanges = defaultAnimateLayoutChanges,\n    attributes: userDefinedAttributes,\n    disabled,\n    data: customData,\n    getNewIndex = defaultNewIndexGetter,\n    id,\n    strategy: localStrategy,\n    resizeObserverConfig,\n    transition = defaultTransition\n  } = _ref9;\n  const {\n    items,\n    containerId,\n    activeIndex,\n    disableTransforms,\n    sortedRects,\n    overIndex,\n    useDragOverlay,\n    strategy: globalStrategy\n  } = useContext(Context);\n  const index = items.indexOf(id);\n  const data = useMemo(() => ({\n    sortable: {\n      containerId,\n      index,\n      items\n    },\n    ...customData\n  }), [containerId, customData, index, items]);\n  const itemsAfterCurrentSortable = useMemo(() => items.slice(items.indexOf(id)), [items, id]);\n  const {\n    rect,\n    node,\n    isOver,\n    setNodeRef: setDroppableNodeRef\n  } = useDroppable({\n    id,\n    data,\n    resizeObserverConfig: {\n      updateMeasurementsFor: itemsAfterCurrentSortable,\n      ...resizeObserverConfig\n    }\n  });\n  const {\n    active,\n    activatorEvent,\n    activeNodeRect,\n    attributes,\n    setNodeRef: setDraggableNodeRef,\n    listeners,\n    isDragging,\n    over,\n    transform\n  } = useDraggable({\n    id,\n    data,\n    attributes: { ...defaultAttributes,\n      ...userDefinedAttributes\n    },\n    disabled\n  });\n  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);\n  const isSorting = Boolean(active);\n  const displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);\n  const shouldDisplaceDragSource = !useDragOverlay && isDragging;\n  const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;\n  const strategy = localStrategy != null ? localStrategy : globalStrategy;\n  const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({\n    rects: sortedRects,\n    activeNodeRect,\n    activeIndex,\n    overIndex,\n    index\n  }) : null;\n  const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({\n    id,\n    items,\n    activeIndex,\n    overIndex\n  }) : index;\n  const activeId = active == null ? void 0 : active.id;\n  const previous = useRef({\n    activeId,\n    items,\n    newIndex,\n    containerId\n  });\n  const itemsHaveChanged = items !== previous.current.items;\n  const shouldAnimateLayoutChanges = animateLayoutChanges({\n    active,\n    containerId,\n    isDragging,\n    isSorting,\n    id,\n    index,\n    items,\n    newIndex: previous.current.newIndex,\n    previousItems: previous.current.items,\n    previousContainerId: previous.current.containerId,\n    transition,\n    wasDragging: previous.current.activeId != null\n  });\n  const derivedTransform = useDerivedTransform({\n    disabled: !shouldAnimateLayoutChanges,\n    index,\n    node,\n    rect\n  });\n  useEffect(() => {\n    if (isSorting && previous.current.newIndex !== newIndex) {\n      previous.current.newIndex = newIndex;\n    }\n\n    if (containerId !== previous.current.containerId) {\n      previous.current.containerId = containerId;\n    }\n\n    if (items !== previous.current.items) {\n      previous.current.items = items;\n    }\n\n    if (activeId !== previous.current.activeId) {\n      previous.current.activeId = activeId;\n    }\n  }, [activeId, isSorting, newIndex, containerId, items]);\n  return {\n    active,\n    activeIndex,\n    attributes,\n    rect,\n    index,\n    newIndex,\n    items,\n    isOver,\n    isSorting,\n    isDragging,\n    listeners,\n    node,\n    overIndex,\n    over,\n    setNodeRef,\n    setDroppableNodeRef,\n    setDraggableNodeRef,\n    transform: derivedTransform != null ? derivedTransform : finalTransform,\n    transition: getTransition()\n  };\n\n  function getTransition() {\n    if ( // Temporarily disable transitions for a single frame to set up derived transforms\n    derivedTransform || // Or to prevent items jumping to back to their \"new\" position when items change\n    itemsHaveChanged && previous.current.newIndex === index) {\n      return disabledTransition;\n    }\n\n    if (shouldDisplaceDragSource && !isKeyboardEvent(activatorEvent) || !transition) {\n      return undefined;\n    }\n\n    if (isSorting || shouldAnimateLayoutChanges) {\n      return CSS.Transition.toString({ ...transition,\n        property: transitionProperty\n      });\n    }\n\n    return undefined;\n  }\n}\n\nconst directions = [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];\n\nconst sortableKeyboardCoordinates = (event, _ref10) => {\n  let {\n    context: {\n      active,\n      droppableContainers,\n      collisionRect,\n      scrollableAncestors\n    }\n  } = _ref10;\n\n  if (directions.includes(event.code)) {\n    event.preventDefault();\n\n    if (!active || !collisionRect) {\n      return;\n    }\n\n    const filteredContainers = [];\n    droppableContainers.getEnabled().forEach(entry => {\n      if (!entry || (entry == null ? void 0 : entry.disabled)) {\n        return;\n      }\n\n      const rect = entry == null ? void 0 : entry.rect.current;\n\n      if (!rect) {\n        return;\n      }\n\n      switch (event.code) {\n        case KeyboardCode.Down:\n          if (collisionRect.top + collisionRect.height <= rect.top) {\n            filteredContainers.push(entry);\n          }\n\n          break;\n\n        case KeyboardCode.Up:\n          if (collisionRect.top >= rect.top + rect.height) {\n            filteredContainers.push(entry);\n          }\n\n          break;\n\n        case KeyboardCode.Left:\n          if (collisionRect.left >= rect.left + rect.width) {\n            filteredContainers.push(entry);\n          }\n\n          break;\n\n        case KeyboardCode.Right:\n          if (collisionRect.left + collisionRect.width <= rect.left) {\n            filteredContainers.push(entry);\n          }\n\n          break;\n      }\n    });\n    const collisions = closestCorners({\n      active,\n      collisionRect: collisionRect,\n      droppableContainers: filteredContainers,\n      pointerCoordinates: null\n    });\n    const closestId = getFirstCollision(collisions, 'id');\n\n    if (closestId != null) {\n      const newDroppable = droppableContainers.get(closestId);\n      const newNode = newDroppable == null ? void 0 : newDroppable.node.current;\n      const newRect = newDroppable == null ? void 0 : newDroppable.rect.current;\n\n      if (newNode && newRect) {\n        const newScrollAncestors = getScrollableAncestors(newNode);\n        const hasDifferentScrollAncestors = newScrollAncestors.some((element, index) => scrollableAncestors[index] !== element);\n        const offset = hasDifferentScrollAncestors ? {\n          x: 0,\n          y: 0\n        } : {\n          x: collisionRect.width - newRect.width,\n          y: collisionRect.height - newRect.height\n        };\n        const newCoordinates = {\n          x: newRect.left - offset.x,\n          y: newRect.top - offset.y\n        };\n        return newCoordinates;\n      }\n    }\n  }\n\n  return undefined;\n};\n\nexport { SortableContext, arrayMove, arraySwap, defaultAnimateLayoutChanges, defaultNewIndexGetter, horizontalListSortingStrategy, rectSortingStrategy, rectSwappingStrategy, sortableKeyboardCoordinates, useSortable, verticalListSortingStrategy };","map":{"version":3,"mappings":"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","names":["arrayMove","array","from","to","newArray","slice","splice","length","arraySwap","getSortedRects","items","rects","reduce","accumulator","id","index","rect","get","Array","isValidIndex","defaultScale","scaleX","scaleY","horizontalListSortingStrategy","activeNodeRect","fallbackActiveRect","activeIndex","overIndex","itemGap","getItemGap","newIndexRect","x","left","width","y","currentRect","previousRect","nextRect","rectSortingStrategy","newRects","oldRect","newRect","top","height","rectSwappingStrategy","verticalListSortingStrategy","overIndexRect","clientRects","ID_PREFIX","Context","React","createContext","containerId","disableTransforms","useDragOverlay","sortedRects","strategy","SortableContext","children","userDefinedItems","active","dragOverlay","droppableRects","over","measureDroppableContainers","measuringScheduled","useDndContext","useUniqueId","Boolean","useMemo","map","item","isDragging","indexOf","previousItemsRef","useRef","itemsHaveChanged","isEqual","current","useIsomorphicLayoutEffect","useEffect","contextValue","Provider","value","arr1","arr2","join","defaultNewIndexGetter","defaultAnimateLayoutChanges","isSorting","wasDragging","newIndex","previousItems","previousContainerId","transition","defaultTransition","duration","easing","transitionProperty","disabledTransition","CSS","Transition","toString","property","defaultAttributes","roleDescription","useDerivedTransform","disabled","node","derivedTransform","setDerivedtransform","useState","previousIndex","initial","getClientRect","ignoreTransform","delta","requestAnimationFrame","useSortable","animateLayoutChanges","attributes","userDefinedAttributes","data","customData","getNewIndex","localStrategy","resizeObserverConfig","globalStrategy","useContext","sortable","itemsAfterCurrentSortable","isOver","setNodeRef","setDroppableNodeRef","useDroppable","updateMeasurementsFor","activatorEvent","setDraggableNodeRef","listeners","transform","useDraggable","useCombinedRefs","displaceItem","shouldDisplaceDragSource","dragSourceDisplacement","finalTransform","activeId","previous","shouldAnimateLayoutChanges","getTransition","isKeyboardEvent","undefined","directions","KeyboardCode","Down","Right","Up","Left","sortableKeyboardCoordinates","event","context","droppableContainers","collisionRect","scrollableAncestors","includes","code","preventDefault","filteredContainers","getEnabled","forEach","entry","push","collisions","closestCorners","pointerCoordinates","closestId","getFirstCollision","newDroppable","newNode","newScrollAncestors","getScrollableAncestors","hasDifferentScrollAncestors","some","element","offset","newCoordinates"],"sources":["/Users/wachiye/works/uncover/staff/node_modules/@dnd-kit/sortable/src/utilities/arrayMove.ts","/Users/wachiye/works/uncover/staff/node_modules/@dnd-kit/sortable/src/utilities/arraySwap.ts","/Users/wachiye/works/uncover/staff/node_modules/@dnd-kit/sortable/src/utilities/getSortedRects.ts","/Users/wachiye/works/uncover/staff/node_modules/@dnd-kit/sortable/src/utilities/isValidIndex.ts","/Users/wachiye/works/uncover/staff/node_modules/@dnd-kit/sortable/src/strategies/horizontalListSorting.ts","/Users/wachiye/works/uncover/staff/node_modules/@dnd-kit/sortable/src/strategies/rectSorting.ts","/Users/wachiye/works/uncover/staff/node_modules/@dnd-kit/sortable/src/strategies/rectSwapping.ts","/Users/wachiye/works/uncover/staff/node_modules/@dnd-kit/sortable/src/strategies/verticalListSorting.ts","/Users/wachiye/works/uncover/staff/node_modules/@dnd-kit/sortable/src/components/SortableContext.tsx","/Users/wachiye/works/uncover/staff/node_modules/@dnd-kit/sortable/src/hooks/defaults.ts","/Users/wachiye/works/uncover/staff/node_modules/@dnd-kit/sortable/src/hooks/utilities/useDerivedTransform.ts","/Users/wachiye/works/uncover/staff/node_modules/@dnd-kit/sortable/src/hooks/useSortable.ts","/Users/wachiye/works/uncover/staff/node_modules/@dnd-kit/sortable/src/sensors/keyboard/sortableKeyboardCoordinates.ts"],"sourcesContent":["/**\n * Move an array item to a different position. Returns a new array with the item moved to the new position.\n */\nexport function arrayMove<T>(array: T[], from: number, to: number): T[] {\n  const newArray = array.slice();\n  newArray.splice(\n    to < 0 ? newArray.length + to : to,\n    0,\n    newArray.splice(from, 1)[0]\n  );\n\n  return newArray;\n}\n","/**\n * Swap an array item to a different position. Returns a new array with the item swapped to the new position.\n */\nexport function arraySwap<T>(array: T[], from: number, to: number): T[] {\n  const newArray = array.slice();\n\n  newArray[from] = array[to];\n  newArray[to] = array[from];\n\n  return newArray;\n}\n","import type {\n  ClientRect,\n  UniqueIdentifier,\n  UseDndContextReturnValue,\n} from '@dnd-kit/core';\n\nexport function getSortedRects(\n  items: UniqueIdentifier[],\n  rects: UseDndContextReturnValue['droppableRects']\n) {\n  return items.reduce<ClientRect[]>((accumulator, id, index) => {\n    const rect = rects.get(id);\n\n    if (rect) {\n      accumulator[index] = rect;\n    }\n\n    return accumulator;\n  }, Array(items.length));\n}\n","export function isValidIndex(index: number | null): index is number {\n  return index !== null && index >= 0;\n}\n","import type {ClientRect} from '@dnd-kit/core';\nimport type {SortingStrategy} from '../types';\n\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1,\n};\n\nexport const horizontalListSortingStrategy: SortingStrategy = ({\n  rects,\n  activeNodeRect: fallbackActiveRect,\n  activeIndex,\n  overIndex,\n  index,\n}) => {\n  const activeNodeRect = rects[activeIndex] ?? fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  const itemGap = getItemGap(rects, index, activeIndex);\n\n  if (index === activeIndex) {\n    const newIndexRect = rects[overIndex];\n\n    if (!newIndexRect) {\n      return null;\n    }\n\n    return {\n      x:\n        activeIndex < overIndex\n          ? newIndexRect.left +\n            newIndexRect.width -\n            (activeNodeRect.left + activeNodeRect.width)\n          : newIndexRect.left - activeNodeRect.left,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: -activeNodeRect.width - itemGap,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: activeNodeRect.width + itemGap,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale,\n  };\n};\n\nfunction getItemGap(rects: ClientRect[], index: number, activeIndex: number) {\n  const currentRect: ClientRect | undefined = rects[index];\n  const previousRect: ClientRect | undefined = rects[index - 1];\n  const nextRect: ClientRect | undefined = rects[index + 1];\n\n  if (!currentRect || (!previousRect && !nextRect)) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect\n      ? currentRect.left - (previousRect.left + previousRect.width)\n      : nextRect.left - (currentRect.left + currentRect.width);\n  }\n\n  return nextRect\n    ? nextRect.left - (currentRect.left + currentRect.width)\n    : currentRect.left - (previousRect.left + previousRect.width);\n}\n","import {arrayMove} from '../utilities';\nimport type {SortingStrategy} from '../types';\n\nexport const rectSortingStrategy: SortingStrategy = ({\n  rects,\n  activeIndex,\n  overIndex,\n  index,\n}) => {\n  const newRects = arrayMove(rects, overIndex, activeIndex);\n\n  const oldRect = rects[index];\n  const newRect = newRects[index];\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.left - oldRect.left,\n    y: newRect.top - oldRect.top,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height,\n  };\n};\n","import type {SortingStrategy} from '../types';\n\nexport const rectSwappingStrategy: SortingStrategy = ({\n  activeIndex,\n  index,\n  rects,\n  overIndex,\n}) => {\n  let oldRect;\n  let newRect;\n\n  if (index === activeIndex) {\n    oldRect = rects[index];\n    newRect = rects[overIndex];\n  }\n\n  if (index === overIndex) {\n    oldRect = rects[index];\n    newRect = rects[activeIndex];\n  }\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.left - oldRect.left,\n    y: newRect.top - oldRect.top,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height,\n  };\n};\n","import type {ClientRect} from '@dnd-kit/core';\nimport type {SortingStrategy} from '../types';\n\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1,\n};\n\nexport const verticalListSortingStrategy: SortingStrategy = ({\n  activeIndex,\n  activeNodeRect: fallbackActiveRect,\n  index,\n  rects,\n  overIndex,\n}) => {\n  const activeNodeRect = rects[activeIndex] ?? fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  if (index === activeIndex) {\n    const overIndexRect = rects[overIndex];\n\n    if (!overIndexRect) {\n      return null;\n    }\n\n    return {\n      x: 0,\n      y:\n        activeIndex < overIndex\n          ? overIndexRect.top +\n            overIndexRect.height -\n            (activeNodeRect.top + activeNodeRect.height)\n          : overIndexRect.top - activeNodeRect.top,\n      ...defaultScale,\n    };\n  }\n\n  const itemGap = getItemGap(rects, index, activeIndex);\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: 0,\n      y: -activeNodeRect.height - itemGap,\n      ...defaultScale,\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: 0,\n      y: activeNodeRect.height + itemGap,\n      ...defaultScale,\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale,\n  };\n};\n\nfunction getItemGap(\n  clientRects: ClientRect[],\n  index: number,\n  activeIndex: number\n) {\n  const currentRect: ClientRect | undefined = clientRects[index];\n  const previousRect: ClientRect | undefined = clientRects[index - 1];\n  const nextRect: ClientRect | undefined = clientRects[index + 1];\n\n  if (!currentRect) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect\n      ? currentRect.top - (previousRect.top + previousRect.height)\n      : nextRect\n      ? nextRect.top - (currentRect.top + currentRect.height)\n      : 0;\n  }\n\n  return nextRect\n    ? nextRect.top - (currentRect.top + currentRect.height)\n    : previousRect\n    ? currentRect.top - (previousRect.top + previousRect.height)\n    : 0;\n}\n","import React, {useEffect, useMemo, useRef} from 'react';\nimport {useDndContext, ClientRect, UniqueIdentifier} from '@dnd-kit/core';\nimport {useIsomorphicLayoutEffect, useUniqueId} from '@dnd-kit/utilities';\n\nimport type {SortingStrategy} from '../types';\nimport {getSortedRects} from '../utilities';\nimport {rectSortingStrategy} from '../strategies';\n\nexport interface Props {\n  children: React.ReactNode;\n  items: (UniqueIdentifier | {id: UniqueIdentifier})[];\n  strategy?: SortingStrategy;\n  id?: string;\n}\n\nconst ID_PREFIX = 'Sortable';\n\ninterface ContextDescriptor {\n  activeIndex: number;\n  containerId: string;\n  disableTransforms: boolean;\n  items: UniqueIdentifier[];\n  overIndex: number;\n  useDragOverlay: boolean;\n  sortedRects: ClientRect[];\n  strategy: SortingStrategy;\n}\n\nexport const Context = React.createContext<ContextDescriptor>({\n  activeIndex: -1,\n  containerId: ID_PREFIX,\n  disableTransforms: false,\n  items: [],\n  overIndex: -1,\n  useDragOverlay: false,\n  sortedRects: [],\n  strategy: rectSortingStrategy,\n});\n\nexport function SortableContext({\n  children,\n  id,\n  items: userDefinedItems,\n  strategy = rectSortingStrategy,\n}: Props) {\n  const {\n    active,\n    dragOverlay,\n    droppableRects,\n    over,\n    measureDroppableContainers,\n    measuringScheduled,\n  } = useDndContext();\n  const containerId = useUniqueId(ID_PREFIX, id);\n  const useDragOverlay = Boolean(dragOverlay.rect !== null);\n  const items = useMemo(\n    () =>\n      userDefinedItems.map((item) =>\n        typeof item === 'string' ? item : item.id\n      ),\n    [userDefinedItems]\n  );\n  const isDragging = active != null;\n  const activeIndex = active ? items.indexOf(active.id) : -1;\n  const overIndex = over ? items.indexOf(over.id) : -1;\n  const previousItemsRef = useRef(items);\n  const itemsHaveChanged = !isEqual(items, previousItemsRef.current);\n  const disableTransforms =\n    (overIndex !== -1 && activeIndex === -1) || itemsHaveChanged;\n\n  useIsomorphicLayoutEffect(() => {\n    if (itemsHaveChanged && isDragging && !measuringScheduled) {\n      measureDroppableContainers(items);\n    }\n  }, [\n    itemsHaveChanged,\n    items,\n    isDragging,\n    measureDroppableContainers,\n    measuringScheduled,\n  ]);\n\n  useEffect(() => {\n    previousItemsRef.current = items;\n  }, [items]);\n\n  const contextValue = useMemo(\n    (): ContextDescriptor => ({\n      activeIndex,\n      containerId,\n      disableTransforms,\n      items,\n      overIndex,\n      useDragOverlay,\n      sortedRects: getSortedRects(items, droppableRects),\n      strategy,\n    }),\n    [\n      activeIndex,\n      containerId,\n      disableTransforms,\n      items,\n      overIndex,\n      droppableRects,\n      useDragOverlay,\n      strategy,\n    ]\n  );\n\n  return <Context.Provider value={contextValue}>{children}</Context.Provider>;\n}\n\nfunction isEqual(arr1: string[], arr2: string[]) {\n  return arr1.join() === arr2.join();\n}\n","import {CSS} from '@dnd-kit/utilities';\n\nimport {arrayMove} from '../utilities';\n\nimport type {\n  AnimateLayoutChanges,\n  NewIndexGetter,\n  SortableTransition,\n} from './types';\n\nexport const defaultNewIndexGetter: NewIndexGetter = ({\n  id,\n  items,\n  activeIndex,\n  overIndex,\n}) => arrayMove(items, activeIndex, overIndex).indexOf(id);\n\nexport const defaultAnimateLayoutChanges: AnimateLayoutChanges = ({\n  containerId,\n  isSorting,\n  wasDragging,\n  index,\n  items,\n  newIndex,\n  previousItems,\n  previousContainerId,\n  transition,\n}) => {\n  if (!transition || !wasDragging) {\n    return false;\n  }\n\n  if (previousItems !== items && index === newIndex) {\n    return false;\n  }\n\n  if (isSorting) {\n    return true;\n  }\n\n  return newIndex !== index && containerId === previousContainerId;\n};\n\nexport const defaultTransition: SortableTransition = {\n  duration: 200,\n  easing: 'ease',\n};\n\nexport const transitionProperty = 'transform';\n\nexport const disabledTransition = CSS.Transition.toString({\n  property: transitionProperty,\n  duration: 0,\n  easing: 'linear',\n});\n\nexport const defaultAttributes = {\n  roleDescription: 'sortable',\n};\n","import {useEffect, useRef, useState} from 'react';\nimport {getClientRect, ClientRect} from '@dnd-kit/core';\nimport {Transform, useIsomorphicLayoutEffect} from '@dnd-kit/utilities';\n\ninterface Arguments {\n  rect: React.MutableRefObject<ClientRect | null>;\n  disabled: boolean;\n  index: number;\n  node: React.MutableRefObject<HTMLElement | null>;\n}\n\n/*\n * When the index of an item changes while sorting,\n * we need to temporarily disable the transforms\n */\nexport function useDerivedTransform({disabled, index, node, rect}: Arguments) {\n  const [derivedTransform, setDerivedtransform] = useState<Transform | null>(\n    null\n  );\n  const previousIndex = useRef(index);\n\n  useIsomorphicLayoutEffect(() => {\n    if (!disabled && index !== previousIndex.current && node.current) {\n      const initial = rect.current;\n\n      if (initial) {\n        const current = getClientRect(node.current, {\n          ignoreTransform: true,\n        });\n\n        const delta = {\n          x: initial.left - current.left,\n          y: initial.top - current.top,\n          scaleX: initial.width / current.width,\n          scaleY: initial.height / current.height,\n        };\n\n        if (delta.x || delta.y) {\n          setDerivedtransform(delta);\n        }\n      }\n    }\n\n    if (index !== previousIndex.current) {\n      previousIndex.current = index;\n    }\n  }, [disabled, index, node, rect]);\n\n  useEffect(() => {\n    if (derivedTransform) {\n      requestAnimationFrame(() => {\n        setDerivedtransform(null);\n      });\n    }\n  }, [derivedTransform]);\n\n  return derivedTransform;\n}\n","import {useContext, useEffect, useMemo, useRef} from 'react';\nimport {\n  useDraggable,\n  useDroppable,\n  UseDraggableArguments,\n  UseDroppableArguments,\n} from '@dnd-kit/core';\nimport {CSS, isKeyboardEvent, useCombinedRefs} from '@dnd-kit/utilities';\n\nimport {Context} from '../components';\nimport type {SortingStrategy} from '../types';\nimport {isValidIndex} from '../utilities';\nimport {\n  defaultAnimateLayoutChanges,\n  defaultAttributes,\n  defaultNewIndexGetter,\n  defaultTransition,\n  disabledTransition,\n  transitionProperty,\n} from './defaults';\nimport type {\n  AnimateLayoutChanges,\n  NewIndexGetter,\n  SortableTransition,\n} from './types';\nimport {useDerivedTransform} from './utilities';\n\nexport interface Arguments\n  extends UseDraggableArguments,\n    Pick<UseDroppableArguments, 'resizeObserverConfig'> {\n  animateLayoutChanges?: AnimateLayoutChanges;\n  getNewIndex?: NewIndexGetter;\n  strategy?: SortingStrategy;\n  transition?: SortableTransition | null;\n}\n\nexport function useSortable({\n  animateLayoutChanges = defaultAnimateLayoutChanges,\n  attributes: userDefinedAttributes,\n  disabled,\n  data: customData,\n  getNewIndex = defaultNewIndexGetter,\n  id,\n  strategy: localStrategy,\n  resizeObserverConfig,\n  transition = defaultTransition,\n}: Arguments) {\n  const {\n    items,\n    containerId,\n    activeIndex,\n    disableTransforms,\n    sortedRects,\n    overIndex,\n    useDragOverlay,\n    strategy: globalStrategy,\n  } = useContext(Context);\n  const index = items.indexOf(id);\n  const data = useMemo(\n    () => ({sortable: {containerId, index, items}, ...customData}),\n    [containerId, customData, index, items]\n  );\n  const itemsAfterCurrentSortable = useMemo(\n    () => items.slice(items.indexOf(id)),\n    [items, id]\n  );\n  const {rect, node, isOver, setNodeRef: setDroppableNodeRef} = useDroppable({\n    id,\n    data,\n    resizeObserverConfig: {\n      updateMeasurementsFor: itemsAfterCurrentSortable,\n      ...resizeObserverConfig,\n    },\n  });\n  const {\n    active,\n    activatorEvent,\n    activeNodeRect,\n    attributes,\n    setNodeRef: setDraggableNodeRef,\n    listeners,\n    isDragging,\n    over,\n    transform,\n  } = useDraggable({\n    id,\n    data,\n    attributes: {\n      ...defaultAttributes,\n      ...userDefinedAttributes,\n    },\n    disabled,\n  });\n  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);\n  const isSorting = Boolean(active);\n  const displaceItem =\n    isSorting &&\n    !disableTransforms &&\n    isValidIndex(activeIndex) &&\n    isValidIndex(overIndex);\n  const shouldDisplaceDragSource = !useDragOverlay && isDragging;\n  const dragSourceDisplacement =\n    shouldDisplaceDragSource && displaceItem ? transform : null;\n  const strategy = localStrategy ?? globalStrategy;\n  const finalTransform = displaceItem\n    ? dragSourceDisplacement ??\n      strategy({\n        rects: sortedRects,\n        activeNodeRect,\n        activeIndex,\n        overIndex,\n        index,\n      })\n    : null;\n  const newIndex =\n    isValidIndex(activeIndex) && isValidIndex(overIndex)\n      ? getNewIndex({id, items, activeIndex, overIndex})\n      : index;\n  const activeId = active?.id;\n  const previous = useRef({\n    activeId,\n    items,\n    newIndex,\n    containerId,\n  });\n  const itemsHaveChanged = items !== previous.current.items;\n  const shouldAnimateLayoutChanges = animateLayoutChanges({\n    active,\n    containerId,\n    isDragging,\n    isSorting,\n    id,\n    index,\n    items,\n    newIndex: previous.current.newIndex,\n    previousItems: previous.current.items,\n    previousContainerId: previous.current.containerId,\n    transition,\n    wasDragging: previous.current.activeId != null,\n  });\n  const derivedTransform = useDerivedTransform({\n    disabled: !shouldAnimateLayoutChanges,\n    index,\n    node,\n    rect,\n  });\n\n  useEffect(() => {\n    if (isSorting && previous.current.newIndex !== newIndex) {\n      previous.current.newIndex = newIndex;\n    }\n\n    if (containerId !== previous.current.containerId) {\n      previous.current.containerId = containerId;\n    }\n\n    if (items !== previous.current.items) {\n      previous.current.items = items;\n    }\n\n    if (activeId !== previous.current.activeId) {\n      previous.current.activeId = activeId;\n    }\n  }, [activeId, isSorting, newIndex, containerId, items]);\n\n  return {\n    active,\n    activeIndex,\n    attributes,\n    rect,\n    index,\n    newIndex,\n    items,\n    isOver,\n    isSorting,\n    isDragging,\n    listeners,\n    node,\n    overIndex,\n    over,\n    setNodeRef,\n    setDroppableNodeRef,\n    setDraggableNodeRef,\n    transform: derivedTransform ?? finalTransform,\n    transition: getTransition(),\n  };\n\n  function getTransition() {\n    if (\n      // Temporarily disable transitions for a single frame to set up derived transforms\n      derivedTransform ||\n      // Or to prevent items jumping to back to their \"new\" position when items change\n      (itemsHaveChanged && previous.current.newIndex === index)\n    ) {\n      return disabledTransition;\n    }\n\n    if (\n      (shouldDisplaceDragSource && !isKeyboardEvent(activatorEvent)) ||\n      !transition\n    ) {\n      return undefined;\n    }\n\n    if (isSorting || shouldAnimateLayoutChanges) {\n      return CSS.Transition.toString({\n        ...transition,\n        property: transitionProperty,\n      });\n    }\n\n    return undefined;\n  }\n}\n","import {\n  closestCorners,\n  getScrollableAncestors,\n  getFirstCollision,\n  KeyboardCode,\n  DroppableContainer,\n  KeyboardCoordinateGetter,\n} from '@dnd-kit/core';\n\nconst directions: string[] = [\n  KeyboardCode.Down,\n  KeyboardCode.Right,\n  KeyboardCode.Up,\n  KeyboardCode.Left,\n];\n\nexport const sortableKeyboardCoordinates: KeyboardCoordinateGetter = (\n  event,\n  {context: {active, droppableContainers, collisionRect, scrollableAncestors}}\n) => {\n  if (directions.includes(event.code)) {\n    event.preventDefault();\n\n    if (!active || !collisionRect) {\n      return;\n    }\n\n    const filteredContainers: DroppableContainer[] = [];\n\n    droppableContainers.getEnabled().forEach((entry) => {\n      if (!entry || entry?.disabled) {\n        return;\n      }\n\n      const rect = entry?.rect.current;\n\n      if (!rect) {\n        return;\n      }\n\n      switch (event.code) {\n        case KeyboardCode.Down:\n          if (collisionRect.top + collisionRect.height <= rect.top) {\n            filteredContainers.push(entry);\n          }\n          break;\n        case KeyboardCode.Up:\n          if (collisionRect.top >= rect.top + rect.height) {\n            filteredContainers.push(entry);\n          }\n          break;\n        case KeyboardCode.Left:\n          if (collisionRect.left >= rect.left + rect.width) {\n            filteredContainers.push(entry);\n          }\n          break;\n        case KeyboardCode.Right:\n          if (collisionRect.left + collisionRect.width <= rect.left) {\n            filteredContainers.push(entry);\n          }\n          break;\n      }\n    });\n\n    const collisions = closestCorners({\n      active,\n      collisionRect: collisionRect,\n      droppableContainers: filteredContainers,\n      pointerCoordinates: null,\n    });\n    const closestId = getFirstCollision(collisions, 'id');\n\n    if (closestId != null) {\n      const newDroppable = droppableContainers.get(closestId);\n      const newNode = newDroppable?.node.current;\n      const newRect = newDroppable?.rect.current;\n\n      if (newNode && newRect) {\n        const newScrollAncestors = getScrollableAncestors(newNode);\n        const hasDifferentScrollAncestors = newScrollAncestors.some(\n          (element, index) => scrollableAncestors[index] !== element\n        );\n        const offset = hasDifferentScrollAncestors\n          ? {\n              x: 0,\n              y: 0,\n            }\n          : {\n              x: collisionRect.width - newRect.width,\n              y: collisionRect.height - newRect.height,\n            };\n        const newCoordinates = {\n          x: newRect.left - offset.x,\n          y: newRect.top - offset.y,\n        };\n\n        return newCoordinates;\n      }\n    }\n  }\n\n  return undefined;\n};\n"]},"metadata":{},"sourceType":"module"}